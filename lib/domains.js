var domains = module.exports = {};
var shell = require('shelljs');
var _ = require('lodash');
var yaml = require('js-yaml');
var utils = require('./utils');
var R = require('ramda');

shell.config.fatal = true;

// All files generated by shasoco will be stored in the folowing directory.
var SHASOCO_PROJ_DIR = process.env.HOME + "/.shasoco/domains";

// The source docker-compose directory.
//
// Note that once deployed, a domain will maintain a copy of the compose
// directory, in SHASOCO_PROJ_DIR, with templates compiled.
//
// This allows multiple projects to run on the same machin with multiple
// shasoco versions.
var COMPOSE_DIR = __dirname + '/../compose';

// Return the path for a per-project (or domain) file.
//
// Hereby, "project" and "domains" are interchangeable words,
// there can be just 1 project per domain and 1 domain per project.
var projectDir = domains.path = function(name) {
    return SHASOCO_PROJ_DIR + "/" + name;
};

// Return the path the project's configuration file.
var projectFile = function(name) {
    return projectDir(name) + "/config.yml";
};

// Returns true if the given domain name exists on the host.
var exists = domains.exists = function(name) {
    return shell.test('-f', projectFile(name));
};

// Return LDAP-compatible DC description of a domain.
// eg. "fovea.cc" is converted to "dc=fovea,dc=cc"
var makeDC = function(name) {
    return name
        .split(".")
        .map(utils.addPrefix("dc="))
        .join(",");
};

// Return input data to feed the templates
//
// It consists of the full configuration file, plus some computed values.
var compileData = function(conf) {
    return _.extend({
        ldapdc: makeDC(conf.name),
        httpHost: conf.name + (conf.httpPort== '80' ? '' : (":" + conf.httpPort)),
        httpsHost: conf.name + (conf.httpsPort == '443' ? '' : (":" + conf.httpsPort))
    }, conf);
};

// Compiles a file located in the source docker-compose directory,
// stores the compiled version in the project directory.
// The template is fed with data from `compileData`.
var compile = R.curry(function(conf, filename) {
    var data = compileData(conf);
    _.template(shell.cat(COMPOSE_DIR + '/' + filename))(data).to(projectDir(conf.name) + '/' + filename);
});

// Generate a new domain configuration directory.
//
// All files from source docker-compose directory are compiled and
// copied to the newly-created project directory.
var create = domains.create = function(name, options) {
    var conf = _.extend({ name:name }, options, {
        salt: utils.genSalt(),
        rootpassword: utils.genPassword(),
        adminpassword: utils.genPassword()
    });
    save(conf);
    generateFiles(conf);
    return conf;
};

// Compiles all files from docker-compose directory,
// store the output into the project directory.
var generateFiles = function(conf) {
    shell.ls(COMPOSE_DIR).forEach(compile(conf));
};

// XXX Is a project upgrade only about re-compiling all files?
var upgrade = domains.upgrade = generateFiles;

// Saves the domain configuration into the project's config.yml file
var save = domains.save = function(conf) {
    conf = _.extend({}, conf);
    delete conf.status; // status is computed, no need to save.
    shell.mkdir('-p', projectDir(conf.name));
    yaml.safeDump(conf).to(projectFile(conf.name));
};

// Return the docker-compose name of a domain
var composeName = domains.composeName = function(name) {
    return name.replace(/\./g, '');
};

// Return true if a domain is running
var isUp = function(name) {
    var ps = shell.exec('docker ps', {silent:true});
    return ps.output.indexOf(" " + composeName(name) + "_") >= 0;
};

// Return true if a domain is not running
var isStopped = function(name) {
    return shell.exec('docker ps -a', {silent:true}).output.indexOf(" " + composeName(name) + "_") >= 0;
};

// Load a project's domain configuration, extended with some dynamic attributes.
var load = domains.load = function(name) {
    var p = shell.cat(projectFile(name));
    var conf = yaml.safeLoad(p);
    conf.status = isUp(name) ? 'UP' : isStopped(name) ? 'SAVED' : 'DOWN';
    return conf;
};

// Same as load, but exit the app with an error when things go wrong.
var safeLoad = domains.safeLoad = function(name, cb) {
    if (!name)
        return utils.error(cb, "domain missing");
    if (!domains.exists(name))
        return utils.error(cb, "domain doesn't exist");
    var conf = domains.load(name);
    if (!conf)
        return utils.error(cb, "failed to load the domain");
    return conf;
};

// Remove a project's directory.
var remove = domains.remove = function(conf) {
    shell.rm('-rf', projectDir(conf.name));
    conf.status = 'REMOVED';
};

// Return the list of all projects
var list = domains.list = function() {
    return shell.ls(projectDir('')).map(load);
};

// Run docker-compose for the given project
var compose = domains.compose = R.curry(function(conf, args) {
    var cwd = shell.pwd();
    shell.cd(projectDir(conf.name));
    shell.exec('docker-compose ' + args);
    shell.cd(cwd);
});
